## Pseudorandom number generator

__all__ = [ "Canvas", "RandomList",
    "prng_sequence", "permute", "PRNG",
    "Card", "poker_rank", "poker_hands",
    "Histogram",
    "view_numberline", "tick_mark", "view_histogram", "update_bin", "view_dotplot", "plot_point"]

from .Tools import Counter, RandomList, enum, classname
from .Canvas import Canvas
from random import randint
from copy import copy

class RandomError(Exception):  pass

## Top level functions

def prng_sequence(a, c, m):
    """
    [RandomLab] Return an array of m numbers defined by the pseudorandom sequence 
    with parameters a, c, and m.  The first number in the sequence is 0, and
    the remaining numbers are defined by the recurrence 
       x[i+1] = (a * x[i] + c) % m
    """
    seq = [0]
    for i in range(m-1):
        seq.append( (a * seq[-1] + c) % m )
    return seq

def permute(a):
    """
    [RandomLab] Randomly permute the items in a, which can be any mutable sequence.
    """
    for i in range(0,len(a)-1):
        r = randint(i, len(a)-1)
        a[i], a[r] = a[r], a[i]
    # return a
    
# def new_deck():
#     """
#     [RandomLab]  Generate a complete deck of cards (52 Card objects).
#     """
#     return [Card(i) for i in range(0,52)]
    
## PRNG class

class PRNG:
    """
    [RandomLab] A PRNG object is a pseudorandom number generator based on the mixed congruential 
    method.  Sequences generated by a PRNG are defined by three constants, named a, c, and m.
    If x[i] is the current item in the sequence, the equation for the next item x[i+1] is
        x[i+1] = (a * x[i] + c) % m
    """
    def __init__(self, a, c, m):
        self._a = a
        self._c = c
        self._m = m
        self._x = 0
        
    def __repr__(self):        
        return "<%s a: %d c: %d m: %d>" % (classname(self), self._a, self._c, self._m)
        
    def state(self):
        """
        [RandomLab]  Return the current item in the pseudorandom sequence (the most recently 
        generated random number)
        """
        return self._x
        
    def seed(self, n):
        """
        [RandomLab]  Set the state of the pseudorandom sequence to n.
        """
        self._x = n % self._m
        return n
        
    def advance(self):
        """
        [RandomLab]  Get the next pseudorandom number in the sequence defined by this PRNG object.
        """
        self._x = (self._x * self._a + self._c) % self._m
        return self._x
        
    def randint(self, i, j):
        """
        [RandomLab]  Get a random integer between i and j from this PRNG object.  Calls
        advance the get the next value from the pseudorandom sequence, then maps it to an 
        integer between i and j.
        """
        if i >= j:  return None
        return (self.advance() % (j - i + 1)) + i
         
## Cards

class Card:
    """
    [RandomLab] A Card object represents a single card from a standard 52-card deck.  The two
    attributes of a card are its rank and suit.
    """
    
    def __init__(self, n = None):
        """
        [RandomLab]  Create a new Card object.  Cards are ordered from 0 to 51, where 0 is
        the two of clubs and 51 is the ace of spades.  If no argument is passed to the constructor
        a random card is created.
        """
        if n == None:  n = randint(0,51)
        if n < 0 or n > 51:  raise RandomError("card number must be between 0 and 51")
#         self._suit = n // 13
#         self._rank = n % 13
        self._id = n
        
    _ascii_suits = { 3: 'S', 2: 'H', 1: 'D', 0: 'C' }
    _unicode_suits = { 3: '\u2660', 2: '\u2665', 1: '\u2666', 0: '\u2663' }
    _suit_symbols = _unicode_suits
    _rank_strings = { 0: '2', 1: '3', 2: '4', 3: '5', 4: '6', 5: '7', 6: '8', 7: '9', 8: '10', 9: 'J', 10: 'Q', 11: 'K', 12: 'A' }
    
    def __repr__(self):
        return Card._rank_strings[self.rank()] + Card._suit_symbols[self.suit()]
        
    def rank(self):
        """
        [RandomLab] Return an integer from 0 to 12 representing the rank of a card.
        """
        # return Card._rank_strings[self._rank]
        # return self._rank
        return self._id % 13

    def suit(self):
        """
        [RandomLab] Return an integer from 0 to 3 representing the suit of a card.
        """
        # return Card._suit_symbols[self._suit]
        # return self._suit
        return self._id // 13

    @staticmethod
    def print_unicode():
        "[RandomLab]  Call Cards.print_unicode() to display suits with 'dingbat' symbols for suits [default]."
        Card._suit_symbols = Card._unicode_suits
    
    @staticmethod
    def print_ascii():
        "[RandomLab]  Call Cards.print_ascii() to display suits as 1-letter abbreviations."
        Card._suit_symbols = Card._ascii_suits
        
    def __eq__(self, other):
        """
        [RandomLab] Two cards are equal if they have the same suit and rank.
        """
        # return self._rank == other._rank and self._suit == other._suit
        return self._id == other._id
        
    def __lt__(self, other):
        """
        [RandomLab] Cards are compared first by suit and then by rank.  The result of sorting 
        a hand (an array of Card objects) is the common ordering used in most card games, where 
        cards are grouped by suit.
        """
#         if self._suit == other._suit:
#             return self._rank < other._rank
#         else:
#             return self._suit < other._suit
        return self._id < other._id

poker_hands = ['high card', 'pair', 'two pair', 'three of a kind', 'straight', 'flush', 'full house', 'four of a kind', 'straight flush']

Poker = enum('Poker', *poker_hands)

def poker_rank(a):
    """
    [RandomLab]  Given an array of 5 Card objects determine what type of poker hand is
    represented by the cards.  The return value is a string, e.g. 'pair', 'full house',
    etc.  A complete list of names is available in the global variable named poker_hands.

    Example (assuming d is a complete deck of 52 Card objects):
    #   >>> h = permute(d)[0:5]
    #   [4♣, 4♦, 7♦, 5♦, 7♥]
    #   >>> poker_rank(h)
    #   'two pair'
    """
    rcount = [0] * len(Card._rank_strings)
    scount = [0] * len(Card._suit_symbols)
    for card in a:
        rcount[card.rank()] += 1
        scount[card.suit()] += 1
    if max(rcount) == 1:
        i, j = lowhigh(rcount)
        straight = j - i == 4
        flush = max(scount) == 5
        if (straight and flush):  return 'straight flush' # Poker.straight_flush  
        if straight: return 'straight' # Poker.straight 
        if flush: return 'flush' # Poker.flush 
        return 'high card' # Poker.high_card
    else:
        if max(rcount) == 4:  return 'four of a kind' # Poker.four_of_a_kind
        if max(rcount) == 3:
            rcount[rcount.index(3)] = 0
            if max(rcount) == 2:
                return 'full house' # Poker.full_house
            else:
                return 'three of a kind' # Poker.three_of_a_kind
        else:
            rcount[rcount.index(2)] = 0
            if max(rcount) == 2:
                return 'two pair' # Poker.two_pair
            else:
                return 'pair' # Poker.pair

def lowhigh(a):
    """[RandomLab] Return the indices of the first and last nonzero items in a"""
    i = 0
    while i < len(a) and a[i] == 0:  i += 1
    j = len(a) - 1
    while j >= 0 and a[j] == 0:  j -= 1
    return (i,j)

## Histogram

class Histogram(dict):
    """
    docstring for Histogram
    """
    def __init__(self, arg1, arg2 = None):
        if type(arg2) == int:
            super().__init__( zip(range(0,arg1), [0]*arg1) )
            self._nbins = arg1
            self._maxval = arg2
            self._keylist = [i for i in range(0,arg1)]
        elif type(arg1) == range or type(arg1) == list or type(arg1) == tuple:
            super().__init__( zip(arg1, [0]*len(arg1)) )
            self._nbins = len(arg1)
            self._maxval = None
            self._keylist = copy(arg1)
        else:
            raise RandomError("histogram labels must be defined by a range, a pair of numbers, or a sequence")
        self._on_canvas = False

    def __setitem__(self, index, value):
        """docstring for __set_item"""
        raise RandomError("can't assign to histogram; use count to update a bin")
        
    def __delitem__(self):
        """docstring for __delitem__"""
        raise RandomError("can't delete a bin from a histogram")
        
    def count(self, k):
        """docstring for count"""
        if self._maxval != None:
            k = self._nbins * k // self._maxval
        super().__setitem__(k, super().__getitem__(k) + 1)
        if self._on_canvas:  update_bin(k)
              
## Visualizations

_default_numberline_options = {
    'lineThickness' : 3, 
    'lineColor' : '#777777', 
    'tickHeight' : 20, 
    'tickColor' : '#0000FF',
    'canvasWidth' : 500,
    'canvasHeight' : 100,
    'padx' : 10,
}

_default_histogram_options = {
    'binColor' : '#000080',
    'boxIncrement' : 8.0,
    'rescaleTrigger' : 50,
}

_default_dotplot_options = {
    'dotColor' : '#000080',
    'canvasSize' : 500,
}

Canvas.delay = 0.01

class NumberLineView:
    def __init__(self, line, npoints, options):
        self.line = line
        self.npoints = npoints
        self.options = options

class HistogramView:
    def __init__(self, h, bins, base, options):
        self.histogram = h
        self.bins = bins
        self.base = base
        self.options = options
        
class DotPlotView:
    def __init__(self, maxval, options):
        self.maxval = maxval
        self.options = options

def view_numberline(npoints, **view_options):
    """
    [RandomLab] Initialize the canvas with a drawing of a number line for integers from 0 to 
    npoints-1.
    """
    options = dict(_default_numberline_options)
    options.update(view_options)
    
    if 'tickWidth' not in options:
        options['tickWidth'] = max(1, options['canvasWidth'] // npoints)      # force width to be multiple of tick width, min = 1px
    options['canvasWidth'] = options['tickWidth'] * npoints
    
    Canvas.init(options['canvasWidth'] + 2*options['padx'], options['canvasHeight'], "RandomLab::NumberLine")
    line = Canvas.Line(options['padx'], 0.7*options['canvasHeight'], options['canvasWidth']+options['padx'], 0.7*options['canvasHeight'], width = options['lineThickness'], fill = options['lineColor'])
    Canvas.view = NumberLineView(line, npoints, options)

def tick_mark(i):
    """
    [RandomLab] Draw a tick mark at location i on the numberline on the canvas
    """
    if type(Canvas.view) != NumberLineView:
        raise RandomError("call view_numberline to initialize the number line")
    elif i < 0 or i > Canvas.view.npoints:
        raise RandomError("tick_mark: i must be between 0 and %d" % Canvas.view.npoints)
    else:
      x0, y0, x1, y1 = Canvas.drawing.coords(Canvas.view.line.id)
      # tx = (i / Canvas.view.npoints) * (x1-x0)
      tx = Canvas.view.options['padx'] + i * Canvas.view.options['tickWidth']
      ty = y0 - Canvas.view.options['tickHeight']
      Canvas.Line(tx, y0, tx, ty, width = Canvas.view.options['tickWidth'], fill = Canvas.view.options['tickColor'])
      Canvas.update()
    
def view_histogram(h, **view_options):
    """
    [RandomLab] Draw a histogram on the canvas.  Make one bar for each counter in the
    histogram where the height of the bar is proportional to the counter.
    """ 
    options = dict(_default_histogram_options)
    options.update(view_options)
    Canvas.init(520, 350, "RandomLab::Histogram")

    bins = []
    binHeight = 3
    binBorder = 2
    binWidth = max(8, (500/(len(h)+1)))         # bins at least 8 pixels wide
    binWidth = min(50, binWidth)                # but not more than 50 pixels
    binTop = 280
    for (i,k) in enumerate(h._keylist):
        x = i * binWidth + binWidth/2
        x0 = x + binBorder
        y0 = binTop - options['boxIncrement'] * h[k]        # bug: needs to rescale if count too high...
        x1 = x + binWidth - binBorder
        y1 = binTop + binHeight
        bins.append(Canvas.Rectangle( x0, y0, x1, y1, outline = options['binColor'], fill = options['binColor'] ))
    
    Canvas.view = HistogramView(h, bins, binTop, options)
    h._on_canvas = True

def update_bin(x):
    """
    [RandomLab] Helper function called automatically by a call to h.count() when
    a histogram is on the canvas.
    """
    if type(Canvas.view) != HistogramView:
        raise RandomError("call view_histogram to initialize the histogram drawing")
    hist = Canvas.view.histogram
    i = hist._keylist.index(x)
    rect = Canvas.view.bins[i]
    x0, y0, x1, y1 = Canvas.drawing.coords(rect.id)
    y0 = y0 - Canvas.view.options['boxIncrement']
    Canvas.drawing.coords(rect.id, x0, y0, x1, y1)
    if y0 < Canvas.view.options['rescaleTrigger']:
        base = Canvas.view.base
        for rect in Canvas.view.bins:
            x0, y0, x1, y1 = Canvas.drawing.coords(rect.id)
            y0 =  base - ((base - y0) / 2)
            Canvas.drawing.coords(rect.id, x0, y0, x1, y1)
        Canvas.view.options['boxIncrement'] /= 2
    Canvas.update()

def view_dotplot(npoints, **view_options):
    """
    [RandomLab] Initialize an empty plot that will be filled in by calls to plot_point.
    """ 
    options = dict(_default_dotplot_options)
    options.update(view_options)
    
    if 'dotSize' not in options:
        options['dotSize'] = max(1, options['canvasSize'] // npoints)      # force size to be multiple of number of points, min = 1px
    options['canvasSize'] = options['dotSize'] * npoints
    
    Canvas.init(options['canvasSize'], options['canvasSize'], "RandomLab::Dot Plot")
    Canvas.view = DotPlotView(npoints, options)
    
def plot_point(x,y):
    """
    [RandomLab] Draw a point at location (x,y).
    """
    if type(Canvas.view) != DotPlotView:
        raise RandomError("call view_dotplot to initialize the dot plot")
    if x < 0 or x >= Canvas.view.maxval or y < 0 or y >= Canvas.view.maxval:
        raise RandomError("plot_point: 0 <= x, y < %d" % Canvas.view.maxval)
    px = (x / Canvas.view.maxval) * Canvas.width()
    py = (y / Canvas.view.maxval) * Canvas.height()
    dxy = Canvas.view.options['dotSize']
    color = Canvas.view.options['dotColor']
    Canvas.Rectangle( px, py, px+dxy, py+dxy, outline = color, fill = color) 

