## Fun with strings and text files (and a spam filter)

__all__ = ["Canvas", "WordQueue", "path_to_data",
    "spamicity", "tokenize", "caesar_cipher", "random_cipher", 
    "load_probabilities", "pspam", "combined_probability", 
    "view_queue", "draw_word", 
    ]

import PythonLabs
from .Tools import PQBase, classname, path_to_data, tokenize
from .Canvas import Canvas

import string
import os
import re

# Dictionary and helper made available for programming projects

from string import ascii_lowercase

caesar_cipher = dict(zip(ascii_lowercase, ascii_lowercase[3:] + ascii_lowercase[:3]))

from random import shuffle
    
def random_cipher():
    a = list(ascii_lowercase)
    shuffle(a)
    return dict(zip(ascii_lowercase,a))
    
## Spam Filtering

# load word probabilites generated by a training set [see make_probabilties.py]

def load_probabilities(fn):
    prob = { }
    with open(fn) as f:
        for line in f:
            p, w = line.split()
            prob[w] = float(p)
    return prob
    
# The Bayesian definition of p(spam | w) uses a prior

def posterior(word, pbad, pgood, prior = 0.8):
    if word in pbad and word in pgood:
        pb = pbad[word] * prior
        pg = pgood[word] * (1 - prior)
        return pb / (pb + pg)
    elif word in pbad:
        return 0.999
    elif word in pgood:
        return 0.001
    else:
        return prior
        
# A simpler definition for when the prior is assume to be 0.5.  Note the return
# value is None if the word isn't in one of the training sets.

def spamicity(word, pbad, pgood):
    if word in pbad and word in pgood:
        p = pbad[word] / (pbad[word] + pgood[word])
        return p
    else:
        return None

# Graham's definition, using word counts

def spam_word(word, nbad, bad, ngood, good):
    if word in good:
        g = 2 * good[word]
    else:
        g = 0
    if word in bad:
        b = bad[word]
    else:
        b = 0
    if g + b > 5:
        pb = min(1.0, b / nbad)
        pg = min(1.0, g / ngood)
        p = pb / (pb + pg)
        return max(0.01, min(0.99, p))
    else:
        return None

def pspam(mfile, vis = 0.2):
    """
    [SpamLab] Compute the probability that a message is spam using the word probabilities
    pbad and pgood derived from a training set.  If the 'vis' argument is not None the
    words in the file will be displayed in a queue on the canvas, and the visualization
    will pause for the specified amount of time after processing each word.
    """
    pbad = load_probabilities(path_to_data("bad.txt"))
    pgood = load_probabilities(path_to_data("good.txt")) 
    queue = WordQueue(15)
    if vis > 0:
        view_queue(queue)
        Canvas.delay = vis
    with open(mfile) as mf: 
        for line in mf:
            for w in tokenize(line):
                p = spamicity(w, pbad, pgood)
                if p != None:
                    queue.insert(w, p)
    return combined_probability(queue)
    
def combined_probability(queue):
    p = q = 1.0
    for x in queue.probs():
        p *= x
        q *= (1.0 - x)
    return p / (p + q)


## Priority Queue for SpamLab...

class WordQueue(PQBase):
    """
    [SpamLab] A WordQueue is an ordered collection of "interesting" words.  Add words by calling
    insert.  Words are automatically removed when the queue grows beyond its maximum size
    (specified when the queue is created).
    """
    def __init__(self, size):
        "[SpamLab] Create a new word queue, initially empty."
        super().__init__()
        self._capacity = size
        self._on_canvas = False
        
    def insert(self, word, prob):
        "[SpamLab] Save a word and its probabilty in the queue"
        score = abs(prob - 0.5)
        i = 0
        while i < len(self._q) and score < self._q[i][2]:
            i += 1
        if i < len(self._q) and word == self._q[i][0]:
            return;
        if i < self._capacity:
            self._q.insert(i, (word, prob, score))
        last = None
        if len(self._q) > self._capacity:
            last = self._q.pop(self._capacity)
        if self._on_canvas:
            update_view(self, i, word, prob, score, last)

    def words(self):
        "[SpamLabs] Generate the sequence of words in the queue"
        for x in self._q:
            yield x[0]

    def probs(self):
        "[SpamLabs] Generate the sequence of probabilities of words in the queue"
        for x in self._q:
            yield x[1]
            
## Visualization

class QueueView:
    def __init__(self, queue, options):
        self.queue = queue
        self.boxes = []
        self.options = options

_qx = 50                # left edge of boxes in queue
_qy = 50                # top edge of first box in queue
_box_height = 20
_box_width = 200

_queue_view_options = {
    'box_bg' : "gray",
    'box_highlight' : "blue",
    'box_line' : "black",
    'word_bg' : "#E8E8E8",
}

def view_queue(wq, **user_options):
    options = dict(_queue_view_options)
    options.update(user_options)
    cw = (3 * _qx) + (2 * _box_width) + 20
    ch = (2 * _qy) + (wq._capacity * _box_height) + 20
    Canvas.init(cw, ch, "SpamLab: Word Queue")
    Canvas.delay = 0.5
    view = QueueView(wq, options)
    Canvas.register(view)
    wq._on_canvas = True
    y = _qy
    for i in range(0,wq._capacity):
        view.boxes.append(Canvas.Rectangle(_qx, y, _qx + _box_width, y + _box_height, fill = options['box_bg'], outline = options['box_line'], tag = "box%s" % i))
        y += _box_height
    return view
    
def tag_for(w):
    return 'x_' + w
    
def draw_word(word, prob, score):
    options = Canvas.view.options
    x = 2 * _qx + _box_width 
    y = _qy
    rect = Canvas.Rectangle(x, y, x + _box_width, y + _box_height, fill = options['word_bg'], outline = options['box_line'], tag = tag_for(word))
    Canvas.Text(" [%.2f] %.2f %s" % (score, prob, word), x, y + _box_height/2, anchor = 'w', font = ("Courier", 12), tag = tag_for(word))
    return rect
    
def update_view(q, loc, word, prob, score, last):
    wordbox = draw_word(word, prob, score)
    Canvas.update()
    
    if loc < len(q):
        if last:
            Canvas.drawing.delete(tag_for(last[0]))
        for i in range(loc+1, len(q)):
            w = q[i][0]
            Canvas.drawing.move(tag_for(w), 0, _box_height)
        box = "box%s" % loc
        Canvas.drawing.lift(box)
        Canvas.drawing.itemconfigure(box, outline = Canvas.view.options['box_highlight'])
        Canvas.update()
        
        Canvas.drawing.lower(box)
        Canvas.drawing.itemconfigure(box, outline = Canvas.view.options['box_line'])
        Canvas.drawing.move(tag_for(word), -(_qx + _box_width), (loc * _box_height))
        Canvas.update()
    else:
        Canvas.drawing.itemconfigure(wordbox.id, outline = 'red')
        Canvas.update()
        
        Canvas.drawing.delete(tag_for(word))
        Canvas.update()
